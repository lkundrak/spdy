// spdy/protocol.go

package spdy

import (
	"bytes"
	"compress/zlib"
	"encoding/binary"
	"fmt"
	"io"
	"net/http"
	"strings"
	"sync"
)

type ControlFrameType uint16

// Control frame type constants
const (
	TypeSynStream    = 0x0001
	TypeSynReply     = 0x0002
	TypeRstStream    = 0x0003
	TypeSettings     = 0x0004
	TypeNoop         = 0x0005
	TypePing         = 0x0006
	TypeGoaway       = 0x0007
	TypeHeaders      = 0x0008
	TypeWindowUpdate = 0x0009
)

func (t ControlFrameType) String() string {
	switch t {
	case TypeSynStream:
		return "SYN_STREAM"
	case TypeSynReply:
		return "SYN_REPLY"
	case TypeRstStream:
		return "RST_STREAM"
	case TypeSettings:
		return "SETTINGS"
	case TypeNoop:
		return "NOOP"
	case TypePing:
		return "PING"
	case TypeGoaway:
		return "GOAWAY"
	case TypeHeaders:
		return "HEADERS"
	case TypeWindowUpdate:
		return "WINDOW_UPDATE"
	}
	return fmt.Sprintf("Type(%#04x)", uint16(t))
}

type FrameFlags uint8

// Frame flag constants
const (
	FlagFin                              = 0x01
	FlagUnidirectional                   = 0x02
	FlagClearPreviouslyPersistedSettings = 0x01
)

// A Frame is the low-level construct passed over a SPDY connection.
type Frame interface {
	io.WriterTo // WriteTo method writes the packet in SPDY format.
	GetFlags() FrameFlags
	GetData() []byte
}

// ControlFrame holds a generic control frame.
type ControlFrame struct {
	Type  ControlFrameType
	Flags FrameFlags
	Data  []byte
}

func (f ControlFrame) GetFlags() FrameFlags { return f.Flags }
func (f ControlFrame) GetData() []byte      { return f.Data }

func (f ControlFrame) WriteTo(w io.Writer) (n int64, err error) {
	nn, err := writeFrame(w, []interface{}{uint16(0x8003), f.Type, f.Flags}, f.Data)
	return int64(nn), err
}

// MaxDataLength is the maximum number of bytes that can be stored in one frame.
const MaxDataLength = 1<<24 - 1

// A DataFrame stores a data frame and its associated metadata.
type DataFrame struct {
	StreamID uint32
	Flags    FrameFlags
	Data     []byte
}

func (f DataFrame) GetFlags() FrameFlags { return f.Flags }
func (f DataFrame) GetData() []byte      { return f.Data }

func (f DataFrame) WriteTo(w io.Writer) (n int64, err error) {
	nn, err := writeFrame(w, []interface{}{f.StreamID & 0x7fffffff, f.Flags}, f.Data)
	return int64(nn), err
}

const frameHeadSize = 5 // in bytes, excluding length field

// ReadFrame reads an entire frame into memory.
func ReadFrame(r io.Reader) (f Frame, err error) {
	headBuffer := new(bytes.Buffer)
	_, err = io.CopyN(headBuffer, r, frameHeadSize)
	if err != nil {
		return
	}
	if headBuffer.Bytes()[0]&0x80 == 0 {
		// Data
		df := DataFrame{}
		err = readBinary(headBuffer, &df.StreamID, &df.Flags)
		if err != nil {
			return
		}
		df.Data, err = readData(r)
		f = df
	} else {
		// Control
		cf := ControlFrame{}
		headBuffer.ReadByte()
		headBuffer.ReadByte() // skip version word
		err = readBinary(headBuffer, &cf.Type, &cf.Flags)
		if err != nil {
			return
		}
		cf.Data, err = readData(r)
		f = cf
	}
	return
}

func readBinary(r io.Reader, args ...interface{}) (err error) {
	for _, a := range args {
		err = binary.Read(r, binary.BigEndian, a)
		if err != nil {
			return
		}
	}
	return
}

func readData(r io.Reader) (data []byte, err error) {
	lengthField := make([]byte, 3)
	_, err = io.ReadFull(r, lengthField)
	if err != nil {
		return
	}
	var length uint32
	length |= uint32(lengthField[0]) << 16
	length |= uint32(lengthField[1]) << 8
	length |= uint32(lengthField[2])

	if length > 0 {
		data = make([]byte, int(length))
		_, err = io.ReadFull(r, data)
		if err != nil {
			data = nil
			return
		}
	} else {
		data = []byte{}
	}
	return
}

func writeFrame(w io.Writer, head []interface{}, data []byte) (n int, err error) {
	var nn int
	// Header (40 bits)
	err = writeBinary(w, head...)
	if err != nil {
		return
	}
	n += frameHeadSize
	// Length (24 bits)
	length := len(data)
	nn, err = w.Write([]byte{
		byte(length & 0x00ff0000 >> 16),
		byte(length & 0x0000ff00 >> 8),
		byte(length & 0x000000ff),
	})
	n += nn
	if err != nil {
		return
	}
	// Data
	if length > 0 {
		nn, err = w.Write(data)
		n += nn
	}
	return
}

func writeBinary(r io.Writer, args ...interface{}) (err error) {
	for _, a := range args {
		err = binary.Write(r, binary.BigEndian, a)
		if err != nil {
			return
		}
	}
	return
}

const headerDictionary = "\x00\x00\x00\x07\x6f\x70\x74\x69\x6f\x6e\x73\x00\x00\x00\x04\x68\x65" +
	"\x61\x64\x00\x00\x00\x04\x70\x6f\x73\x74\x00\x00\x00\x03\x70\x75\x74" +
	"\x00\x00\x00\x06\x64\x65\x6c\x65\x74\x65\x00\x00\x00\x05\x74\x72\x61" +
	"\x63\x65\x00\x00\x00\x06\x61\x63\x63\x65\x70\x74\x00\x00\x00\x0e\x61" +
	"\x63\x63\x65\x70\x74\x2d\x63\x68\x61\x72\x73\x65\x74\x00\x00\x00\x0f" +
	"\x61\x63\x63\x65\x70\x74\x2d\x65\x6e\x63\x6f\x64\x69\x6e\x67\x00\x00" +
	"\x00\x0f\x61\x63\x63\x65\x70\x74\x2d\x6c\x61\x6e\x67\x75\x61\x67\x65" +
	"\x00\x00\x00\x0d\x61\x63\x63\x65\x70\x74\x2d\x72\x61\x6e\x67\x65\x73" +
	"\x00\x00\x00\x03\x61\x67\x65\x00\x00\x00\x05\x61\x6c\x6c\x6f\x77\x00" +
	"\x00\x00\x0d\x61\x75\x74\x68\x6f\x72\x69\x7a\x61\x74\x69\x6f\x6e\x00" +
	"\x00\x00\x0d\x63\x61\x63\x68\x65\x2d\x63\x6f\x6e\x74\x72\x6f\x6c\x00" +
	"\x00\x00\x0a\x63\x6f\x6e\x6e\x65\x63\x74\x69\x6f\x6e\x00\x00\x00\x0c" +
	"\x63\x6f\x6e\x74\x65\x6e\x74\x2d\x62\x61\x73\x65\x00\x00\x00\x10\x63" +
	"\x6f\x6e\x74\x65\x6e\x74\x2d\x65\x6e\x63\x6f\x64\x69\x6e\x67\x00\x00" +
	"\x00\x10\x63\x6f\x6e\x74\x65\x6e\x74\x2d\x6c\x61\x6e\x67\x75\x61\x67" +
	"\x65\x00\x00\x00\x0e\x63\x6f\x6e\x74\x65\x6e\x74\x2d\x6c\x65\x6e\x67" +
	"\x74\x68\x00\x00\x00\x10\x63\x6f\x6e\x74\x65\x6e\x74\x2d\x6c\x6f\x63" +
	"\x61\x74\x69\x6f\x6e\x00\x00\x00\x0b\x63\x6f\x6e\x74\x65\x6e\x74\x2d" +
	"\x6d\x64\x35\x00\x00\x00\x0d\x63\x6f\x6e\x74\x65\x6e\x74\x2d\x72\x61" +
	"\x6e\x67\x65\x00\x00\x00\x0c\x63\x6f\x6e\x74\x65\x6e\x74\x2d\x74\x79" +
	"\x70\x65\x00\x00\x00\x04\x64\x61\x74\x65\x00\x00\x00\x04\x65\x74\x61" +
	"\x67\x00\x00\x00\x06\x65\x78\x70\x65\x63\x74\x00\x00\x00\x07\x65\x78" +
	"\x70\x69\x72\x65\x73\x00\x00\x00\x04\x66\x72\x6f\x6d\x00\x00\x00\x04" +
	"\x68\x6f\x73\x74\x00\x00\x00\x08\x69\x66\x2d\x6d\x61\x74\x63\x68\x00" +
	"\x00\x00\x11\x69\x66\x2d\x6d\x6f\x64\x69\x66\x69\x65\x64\x2d\x73\x69" +
	"\x6e\x63\x65\x00\x00\x00\x0d\x69\x66\x2d\x6e\x6f\x6e\x65\x2d\x6d\x61" +
	"\x74\x63\x68\x00\x00\x00\x08\x69\x66\x2d\x72\x61\x6e\x67\x65\x00\x00" +
	"\x00\x13\x69\x66\x2d\x75\x6e\x6d\x6f\x64\x69\x66\x69\x65\x64\x2d\x73" +
	"\x69\x6e\x63\x65\x00\x00\x00\x0d\x6c\x61\x73\x74\x2d\x6d\x6f\x64\x69" +
	"\x66\x69\x65\x64\x00\x00\x00\x08\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x00" +
	"\x00\x00\x0c\x6d\x61\x78\x2d\x66\x6f\x72\x77\x61\x72\x64\x73\x00\x00" +
	"\x00\x06\x70\x72\x61\x67\x6d\x61\x00\x00\x00\x12\x70\x72\x6f\x78\x79" +
	"\x2d\x61\x75\x74\x68\x65\x6e\x74\x69\x63\x61\x74\x65\x00\x00\x00\x13" +
	"\x70\x72\x6f\x78\x79\x2d\x61\x75\x74\x68\x6f\x72\x69\x7a\x61\x74\x69" +
	"\x6f\x6e\x00\x00\x00\x05\x72\x61\x6e\x67\x65\x00\x00\x00\x07\x72\x65" +
	"\x66\x65\x72\x65\x72\x00\x00\x00\x0b\x72\x65\x74\x72\x79\x2d\x61\x66" +
	"\x74\x65\x72\x00\x00\x00\x06\x73\x65\x72\x76\x65\x72\x00\x00\x00\x02" +
	"\x74\x65\x00\x00\x00\x07\x74\x72\x61\x69\x6c\x65\x72\x00\x00\x00\x11" +
	"\x74\x72\x61\x6e\x73\x66\x65\x72\x2d\x65\x6e\x63\x6f\x64\x69\x6e\x67" +
	"\x00\x00\x00\x07\x75\x70\x67\x72\x61\x64\x65\x00\x00\x00\x0a\x75\x73" +
	"\x65\x72\x2d\x61\x67\x65\x6e\x74\x00\x00\x00\x04\x76\x61\x72\x79\x00" +
	"\x00\x00\x03\x76\x69\x61\x00\x00\x00\x07\x77\x61\x72\x6e\x69\x6e\x67" +
	"\x00\x00\x00\x10\x77\x77\x77\x2d\x61\x75\x74\x68\x65\x6e\x74\x69\x63" +
	"\x61\x74\x65\x00\x00\x00\x06\x6d\x65\x74\x68\x6f\x64\x00\x00\x00\x03" +
	"\x67\x65\x74\x00\x00\x00\x06\x73\x74\x61\x74\x75\x73\x00\x00\x00\x06" +
	"\x32\x30\x30\x20\x4f\x4b\x00\x00\x00\x07\x76\x65\x72\x73\x69\x6f\x6e" +
	"\x00\x00\x00\x08\x48\x54\x54\x50\x2f\x31\x2e\x31\x00\x00\x00\x03\x75" +
	"\x72\x6c\x00\x00\x00\x06\x70\x75\x62\x6c\x69\x63\x00\x00\x00\x0a\x73" +
	"\x65\x74\x2d\x63\x6f\x6f\x6b\x69\x65\x00\x00\x00\x0a\x6b\x65\x65\x70" +
	"\x2d\x61\x6c\x69\x76\x65\x00\x00\x00\x06\x6f\x72\x69\x67\x69\x6e\x31" +
	"\x30\x30\x31\x30\x31\x32\x30\x31\x32\x30\x32\x32\x30\x35\x32\x30\x36" +
	"\x33\x30\x30\x33\x30\x32\x33\x30\x33\x33\x30\x34\x33\x30\x35\x33\x30" +
	"\x36\x33\x30\x37\x34\x30\x32\x34\x30\x35\x34\x30\x36\x34\x30\x37\x34" +
	"\x30\x38\x34\x30\x39\x34\x31\x30\x34\x31\x31\x34\x31\x32\x34\x31\x33" +
	"\x34\x31\x34\x34\x31\x35\x34\x31\x36\x34\x31\x37\x35\x30\x32\x35\x30" +
	"\x34\x35\x30\x35\x32\x30\x33\x20\x4e\x6f\x6e\x2d\x41\x75\x74\x68\x6f" +
	"\x72\x69\x74\x61\x74\x69\x76\x65\x20\x49\x6e\x66\x6f\x72\x6d\x61\x74" +
	"\x69\x6f\x6e\x32\x30\x34\x20\x4e\x6f\x20\x43\x6f\x6e\x74\x65\x6e\x74" +
	"\x33\x30\x31\x20\x4d\x6f\x76\x65\x64\x20\x50\x65\x72\x6d\x61\x6e\x65" +
	"\x6e\x74\x6c\x79\x34\x30\x30\x20\x42\x61\x64\x20\x52\x65\x71\x75\x65" +
	"\x73\x74\x34\x30\x31\x20\x55\x6e\x61\x75\x74\x68\x6f\x72\x69\x7a\x65" +
	"\x64\x34\x30\x33\x20\x46\x6f\x72\x62\x69\x64\x64\x65\x6e\x34\x30\x34" +
	"\x20\x4e\x6f\x74\x20\x46\x6f\x75\x6e\x64\x35\x30\x30\x20\x49\x6e\x74" +
	"\x65\x72\x6e\x61\x6c\x20\x53\x65\x72\x76\x65\x72\x20\x45\x72\x72\x6f" +
	"\x72\x35\x30\x31\x20\x4e\x6f\x74\x20\x49\x6d\x70\x6c\x65\x6d\x65\x6e" +
	"\x74\x65\x64\x35\x30\x33\x20\x53\x65\x72\x76\x69\x63\x65\x20\x55\x6e" +
	"\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x4a\x61\x6e\x20\x46\x65\x62\x20" +
	"\x4d\x61\x72\x20\x41\x70\x72\x20\x4d\x61\x79\x20\x4a\x75\x6e\x20\x4a" +
	"\x75\x6c\x20\x41\x75\x67\x20\x53\x65\x70\x74\x20\x4f\x63\x74\x20\x4e" +
	"\x6f\x76\x20\x44\x65\x63\x20\x30\x30\x3a\x30\x30\x3a\x30\x30\x20\x4d" +
	"\x6f\x6e\x2c\x20\x54\x75\x65\x2c\x20\x57\x65\x64\x2c\x20\x54\x68\x75" +
	"\x2c\x20\x46\x72\x69\x2c\x20\x53\x61\x74\x2c\x20\x53\x75\x6e\x2c\x20" +
	"\x47\x4d\x54\x63\x68\x75\x6e\x6b\x65\x64\x2c\x74\x65\x78\x74\x2f\x68" +
	"\x74\x6d\x6c\x2c\x69\x6d\x61\x67\x65\x2f\x70\x6e\x67\x2c\x69\x6d\x61" +
	"\x67\x65\x2f\x6a\x70\x67\x2c\x69\x6d\x61\x67\x65\x2f\x67\x69\x66\x2c" +
	"\x61\x70\x70\x6c\x69\x63\x61\x74\x69\x6f\x6e\x2f\x78\x6d\x6c\x2c\x61" +
	"\x70\x70\x6c\x69\x63\x61\x74\x69\x6f\x6e\x2f\x78\x68\x74\x6d\x6c\x2b" +
	"\x78\x6d\x6c\x2c\x74\x65\x78\x74\x2f\x70\x6c\x61\x69\x6e\x2c\x74\x65" +
	"\x78\x74\x2f\x6a\x61\x76\x61\x73\x63\x72\x69\x70\x74\x2c\x70\x75\x62" +
	"\x6c\x69\x63\x70\x72\x69\x76\x61\x74\x65\x6d\x61\x78\x2d\x61\x67\x65" +
	"\x3d\x67\x7a\x69\x70\x2c\x64\x65\x66\x6c\x61\x74\x65\x2c\x73\x64\x63" +
	"\x68\x63\x68\x61\x72\x73\x65\x74\x3d\x75\x74\x66\x2d\x38\x63\x68\x61" +
	"\x72\x73\x65\x74\x3d\x69\x73\x6f\x2d\x38\x38\x35\x39\x2d\x31\x2c\x75" +
	"\x74\x66\x2d\x2c\x2a\x2c\x65\x6e\x71\x3d\x30\x2e"

type hrSource struct {
	r io.Reader
	m sync.RWMutex
	c *sync.Cond
}

func (src *hrSource) Read(p []byte) (n int, err error) {
	src.m.RLock()
	for src.r == nil {
		src.c.Wait()
	}
	n, err = src.r.Read(p)
	src.m.RUnlock()
	if err == io.EOF {
		src.change(nil)
		err = nil
	}
	return
}

func (src *hrSource) change(r io.Reader) {
	src.m.Lock()
	defer src.m.Unlock()
	src.r = r
	src.c.Broadcast()
}

// A HeaderReader reads zlib-compressed headers from discontiguous sources.
type HeaderReader struct {
	source       hrSource
	decompressor io.ReadCloser
}

// NewHeaderReader creates a HeaderReader with the initial dictionary.
func NewHeaderReader() (hr *HeaderReader) {
	hr = new(HeaderReader)
	hr.source.c = sync.NewCond(hr.source.m.RLocker())
	return
}

// ReadHeader reads a set of headers from a reader.
func (hr *HeaderReader) ReadHeader(r io.Reader) (h http.Header, err error) {
	hr.source.change(r)
	h, err = hr.read()
	return
}

// Decode reads a set of headers from a block of bytes.
func (hr *HeaderReader) Decode(data []byte) (h http.Header, err error) {
	hr.source.change(bytes.NewBuffer(data))
	h, err = hr.read()
	return
}

func (hr *HeaderReader) read() (h http.Header, err error) {
	var count uint32
	if hr.decompressor == nil {
		hr.decompressor, _ = zlib.NewReaderDict(&hr.source, []byte(headerDictionary))
		if err != nil {
			return
		}
	}
	err = binary.Read(hr.decompressor, binary.BigEndian, &count)
	if err != nil {
		return
	}
	h = make(http.Header, int(count))
	for i := 0; i < int(count); i++ {
		var name, value string
		name, err = readHeaderString(hr.decompressor)
		if err != nil {
			return
		}
		value, err = readHeaderString(hr.decompressor)
		if err != nil {
			return
		}
		valueList := strings.Split(string(value), "\x00")
		for _, v := range valueList {
			h.Add(name, v)
		}
	}
	return
}

func readHeaderString(r io.Reader) (s string, err error) {
	var length uint32
	err = binary.Read(r, binary.BigEndian, &length)
	if err != nil {
		return
	}
	data := make([]byte, int(length))
	_, err = io.ReadFull(r, data)
	if err != nil {
		return
	}
	return string(data), nil
}

// HeaderWriter will write zlib-compressed headers on different streams.
type HeaderWriter struct {
	compressor *zlib.Writer
	buffer     *bytes.Buffer
}

// NewHeaderWriter creates a HeaderWriter ready to compress headers.
func NewHeaderWriter(level int) (hw *HeaderWriter) {
	hw = &HeaderWriter{buffer: new(bytes.Buffer)}
	hw.compressor, _ = zlib.NewWriterLevelDict(hw.buffer, level, []byte(headerDictionary))
	return
}

// WriteHeader writes a header block directly to an output.
func (hw *HeaderWriter) WriteHeader(w io.Writer, h http.Header) (err error) {
	hw.write(h)
	_, err = io.Copy(w, hw.buffer)
	hw.buffer.Reset()
	return
}

// Encode returns a compressed header block.
func (hw *HeaderWriter) Encode(h http.Header) (data []byte) {
	hw.write(h)
	data = make([]byte, hw.buffer.Len())
	hw.buffer.Read(data)
	return
}

func (hw *HeaderWriter) write(h http.Header) {
	binary.Write(hw.compressor, binary.BigEndian, uint32(len(h)))
	for k, vals := range h {
		k = strings.ToLower(k)
		binary.Write(hw.compressor, binary.BigEndian, uint32(len(k)))
		binary.Write(hw.compressor, binary.BigEndian, []byte(k))
		v := strings.Join(vals, "\x00")
		binary.Write(hw.compressor, binary.BigEndian, uint32(len(v)))
		binary.Write(hw.compressor, binary.BigEndian, []byte(v))
	}
	hw.compressor.Flush()
}
